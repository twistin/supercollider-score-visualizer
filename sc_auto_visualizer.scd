// =================================================================
// SC SCORE VISUALIZER - SISTEMA DE AUTO-VISUALIZACI√ìN PROFESIONAL
// =================================================================
// 
// Script autocontenido para live coding con visualizaci√≥n autom√°tica
// Compatible con ProxySpace, Pbind, Synth y NodeProxy
// 
// INSTALACI√ìN: Ejecutar paso a paso los bloques marcados con n√∫meros
// USO DIARIO: Solo ejecutar bloque 6 para activar el sistema
// 
// =================================================================

// =================================================================
// 1. CONFIGURACI√ìN GLOBAL
// =================================================================
(
// Configuraci√≥n del visualizador
~visualizerConfig = (
    addr: NetAddr("127.0.0.1", 57124),
    enabled: true,
    debugMode: false,
    analyzerSynth: nil
);

// Configuraci√≥n lista - la conexi√≥n se verificar√° al enviar mensajes
"‚úÖ Configuraci√≥n OSC lista para SC Score Visualizer (puerto 57124)".postln;

"üéØ Configuraci√≥n cargada. Siguiente paso: ejecutar bloque 2".postln;
)

// =================================================================
// 2. SYNTHDEF DEL ANALIZADOR EN TIEMPO REAL
// =================================================================
(
SynthDef(\sc_visualizer_analyzer, {
    var input, amp, freq, centroid, flatness;
    var onset, hasOnset, localAmp;
    var trig, data;
    
    // Capturar TODO el audio del servidor (est√©reo -> mono)
    input = In.ar(0, 2).sum;
    
    // An√°lisis b√°sico
    amp = Amplitude.kr(input, 0.01, 0.1);
    freq = Pitch.kr(input, ampThreshold: 0.02, median: 7)[0];
    
    // An√°lisis espectral
    centroid = SpecCentroid.kr(FFT(LocalBuf(2048), input));
    flatness = SpecFlatness.kr(FFT(LocalBuf(2048), input));
    
    // Detecci√≥n de onset b√°sica
    localAmp = Amplitude.kr(input, 0.001, 0.01);
    onset = localAmp > (DelayN.kr(localAmp, 0.1, 0.1) * 1.5);
    hasOnset = Trig1.kr(onset, 0.1);
    
    // Trigger a 30 FPS para datos continuos
    trig = Impulse.kr(30);
    
    // Env√≠o de datos de an√°lisis en tiempo real
    SendReply.kr(trig, '/realtime_audio', [
        freq.clip(20, 20000),
        amp.clip(0, 1),
        centroid.clip(20, 20000),
        flatness.clip(0, 1),
        hasOnset
    ]);
    
    // Silenciar la salida (solo an√°lisis)
    Out.ar(0, Silent.ar(2));
}).add;

"üî¨ SynthDef del analizador cargado. Siguiente paso: ejecutar bloque 3".postln;
)

// =================================================================
// 3. FUNCIONES HELPER PARA AUTO-VISUALIZACI√ìN
// =================================================================
(
// Helper para Pbind con visualizaci√≥n autom√°tica
~visualPbind = { |...args|
    var pbindArgs, hasCallback, callbackIndex;
    var visualCallback;
    
    pbindArgs = args ?? [];
    
    // Verificar si ya tiene callback
    hasCallback = false;
    callbackIndex = -1;
    pbindArgs.pairsDo({ |key, value, i|
        if(key == \callback, {
            hasCallback = true;
            callbackIndex = i + 1;
        });
    });
    
    // Crear callback de visualizaci√≥n
    visualCallback = { |event|
        var freq, amp, dur, rel, timbre, curvature, cf;
        
        if(~visualizerConfig.enabled, {
            freq = event[\freq] ?? 440;
            amp = event[\amp] ?? 0.5;
            dur = event[\dur] ?? 1.0;
            rel = event[\rel] ?? dur;
            timbre = event[\timbre] ?? 0.5;
            curvature = event[\curvature] ?? 0.0;
            cf = event[\cf] ?? freq;
            
            // Enviar evento OSC
            ~visualizerConfig.addr.sendMsg("/event", "pbind", 
                freq.asFloat, amp.asFloat, rel.asFloat, 
                timbre.asFloat, curvature.asFloat, cf.asFloat);
                
            if(~visualizerConfig.debugMode, {
                "üìä Visual event: freq:% amp:% dur:%".format(freq, amp, rel).postln;
            });
        });
    };
    
    // Si no tiene callback, agregarlo
    if(hasCallback.not, {
        pbindArgs = pbindArgs ++ [\callback, visualCallback];
    });
    
    // Crear y devolver el Pbind
    Pbind(*pbindArgs);
};

// Helper para Synth con visualizaci√≥n autom√°tica
~visualSynth = { |defName, args|
    var freq, amp, dur;
    var argsList, i, synth;
    
    argsList = args ?? [];
    
    // Extraer par√°metros comunes usando b√∫squeda manual
    freq = 440;
    amp = 0.5;
    dur = 1.0;
    
    // Buscar freq, amp, dur en la lista de argumentos
    i = 0;
    while({ i < (argsList.size - 1) }, {
        if(argsList[i] == \freq, { freq = argsList[i + 1] });
        if(argsList[i] == \amp, { amp = argsList[i + 1] });
        if(argsList[i] == \dur, { dur = argsList[i + 1] });
        i = i + 2;
    });
    
    // Crear el synth
    synth = Synth(defName, argsList);
    
    // Enviar visualizaci√≥n si est√° habilitada
    if(~visualizerConfig.enabled, {
        ~visualizerConfig.addr.sendMsg("/event", "synth", 
            freq.asFloat, amp.asFloat, dur.asFloat, 0.5, 0.0, freq.asFloat);
            
        if(~visualizerConfig.debugMode, {
            "üéµ Visual synth: % freq:% amp:%".format(defName, freq, amp).postln;
        });
    });
    
    synth;
};

// Helper para NodeProxy con visualizaci√≥n autom√°tica
~visualProxy = { |proxy, freq, amp|
    var proxyFreq, proxyAmp;
    
    proxyFreq = freq ?? 440;
    proxyAmp = amp ?? 0.5;
    
    // Reproducir el proxy
    proxy.play;
    
    // Enviar visualizaci√≥n si est√° habilitada
    if(~visualizerConfig.enabled, {
        ~visualizerConfig.addr.sendMsg("/event", "proxy", 
            proxyFreq.asFloat, proxyAmp.asFloat, 2.0, 0.5, 0.0, proxyFreq.asFloat);
            
        if(~visualizerConfig.debugMode, {
            "üîó Visual proxy: freq:% amp:%".format(proxyFreq, proxyAmp).postln;
        });
    });
    
    proxy;
};

"üõ†Ô∏è Funciones helper cargadas. Siguiente paso: ejecutar bloque 4".postln;
)

// =================================================================
// 4. SISTEMA DE CONTROL Y UTILIDADES
// =================================================================
(
// Activar visualizador
~visualizerOn = {
    ~visualizerConfig.enabled = true;
    "‚úÖ Visualizador ACTIVADO".postln;
};

// Desactivar visualizador
~visualizerOff = {
    ~visualizerConfig.enabled = false;
    "‚ùå Visualizador DESACTIVADO".postln;
};

// Modo debug
~visualizerDebug = { |enable|
    enable = enable ?? true;
    ~visualizerConfig.debugMode = enable;
    if(enable, {
        "üêõ Modo debug ACTIVADO".postln;
    }, {
        "üêõ Modo debug DESACTIVADO".postln;
    });
};

// Iniciar analizador en tiempo real
~startAnalyzer = {
    if(~visualizerConfig.analyzerSynth.notNil, {
        ~visualizerConfig.analyzerSynth.free;
    });
    
    ~visualizerConfig.analyzerSynth = Synth(\sc_visualizer_analyzer);
    
    "üî¨ Analizador en tiempo real iniciado".postln;
};

// Limpiar recursos del visualizador
~cleanupVisualizer = {
    if(~visualizerConfig.analyzerSynth.notNil, {
        ~visualizerConfig.analyzerSynth.free;
        ~visualizerConfig.analyzerSynth = nil;
    });
    
    "üßπ Recursos del visualizador liberados".postln;
};

// Test de conectividad
~testVisualizer = {
    if(~visualizerConfig.enabled, {
        ~visualizerConfig.addr.sendMsg("/event", "test", 440.0, 0.5, 1.0, 0.5, 0.0, 440.0);
        "üß™ Mensaje de prueba enviado al visualizador".postln;
    }, {
        "‚ö†Ô∏è Visualizador desactivado. Usar ~visualizerOn.value() primero".postln;
    });
};

"üéõÔ∏è Sistema de control cargado. Siguiente paso: ejecutar bloque 5".postln;
)

// =================================================================
// 5. CONFIGURACI√ìN DE PROXYSPACE Y CLEANUP
// =================================================================
(
// Configurar ProxySpace si no est√° activo
if(currentEnvironment.isKindOf(ProxySpace).not, {
    p = ProxySpace.push(s);
    "üåê ProxySpace activado".postln;
});

// Configurar cleanup autom√°tico al cerrar servidor
ServerQuit.add({
    ~cleanupVisualizer.value();
    "üîÑ Cleanup autom√°tico ejecutado".postln;
});

"üîß ProxySpace configurado. Siguiente paso: ejecutar bloque 6".postln;
)

// =================================================================
// 6. ACTIVACI√ìN DEL SISTEMA (USAR PARA SESIONES DIARIAS)
// =================================================================
(
// Activar todo el sistema
~visualizerOn.value();
~startAnalyzer.value();

// Test de conectividad
{
    1.wait;
    ~testVisualizer.value();
}.fork;

"üöÄ SISTEMA DE AUTO-VISUALIZACI√ìN ACTIVADO";
"";
"üìã FUNCIONES DISPONIBLES:";
"   ‚Ä¢ ~visualPbind.value(...) - Pbind con visualizaci√≥n";
"   ‚Ä¢ ~visualSynth.value(defName, args) - Synth con visualizaci√≥n";
"   ‚Ä¢ ~visualProxy.value(proxy, freq, amp) - NodeProxy con visualizaci√≥n";
"";
"üéõÔ∏è CONTROLES:";
"   ‚Ä¢ ~visualizerOn.value() - Activar";
"   ‚Ä¢ ~visualizerOff.value() - Desactivar";
"   ‚Ä¢ ~visualizerDebug.value(true/false) - Debug";
"   ‚Ä¢ ~testVisualizer.value() - Probar conexi√≥n";
"";
"üéµ ¬°Listo para live coding con visualizaci√≥n autom√°tica!";
)

// =================================================================
// 7. EJEMPLOS DE USO PR√ÅCTICO
// =================================================================

/*
// EJEMPLO 1: Pbind con visualizaci√≥n autom√°tica
(
a = ~visualPbind.value(
    \instrument, \default,
    \freq, Pseq([220, 330, 440, 550], inf),
    \dur, 0.25,
    \amp, 0.3,
    \rel, 0.1
);
a.play;
)

// EJEMPLO 2: Synth individual con visualizaci√≥n
~visualSynth.value(\default, [\freq, 880, \amp, 0.4, \dur, 2]);

// EJEMPLO 3: NodeProxy con visualizaci√≥n
(
~pad = { SinOsc.ar([220, 223]) * 0.1 * SinOsc.kr(0.1).range(0.5, 1) };
~visualProxy.value(~pad, 220, 0.1);
)

// EJEMPLO 4: Secuencia compleja
(
// Patr√≥n r√≠tmico
b = ~visualPbind.value(
    \instrument, \default,
    \freq, Pseq([110, 165, 220], inf),
    \dur, Pseq([0.25, 0.125, 0.125], inf),
    \amp, Pseq([0.6, 0.3, 0.4], inf),
    \timbre, Pseq([0.2, 0.8, 0.5], inf)
);

// Pad atmosf√©rico
~ambient = { 
    var freqs = [220, 220*1.5, 220*2];
    var oscs = freqs.collect({ |f| SinOsc.ar(f + SinOsc.kr(0.1).range(-2, 2)) });
    Splay.ar(oscs) * 0.05 * SinOsc.kr(0.05).range(0.3, 1);
};

// Iniciar todo
b.play;
~visualProxy.value(~ambient, 220, 0.05);
)

// CONTROL EN VIVO
~visualizerDebug.value(true);  // Ver eventos en el post window
~visualizerOff.value();        // Pausar visualizaci√≥n
~visualizerOn.value();         // Reanudar visualizaci√≥n

// CLEANUP MANUAL
~cleanupVisualizer.value();    // Liberar recursos
*/

// =================================================================
// üéä SISTEMA LISTO PARA LIVE CODING PROFESIONAL
// =================================================================
//
// MODO DE USO R√ÅPIDO PARA SESIONES DIARIAS:
// 1. Ejecutar solo el bloque 6 para activar todo
// 2. Usar ~visualPbind, ~visualSynth, ~visualProxy normalmente
// 3. Live coding como siempre, ¬°pero con visualizaci√≥n autom√°tica!
//
// TROUBLESHOOTING:
// - Si no ves visualizaci√≥n: verificar que el visualizador est√© ejecut√°ndose
// - Si hay errores OSC: ejecutar ~testVisualizer.value()
// - Para debug: ~visualizerDebug.value(true)
//
// =================================================================
