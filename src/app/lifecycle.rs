// üîÑ Ciclo de vida de la aplicaci√≥n
// Maneja la inicializaci√≥n, actualizaci√≥n y renderizado

use nannou::prelude::*;
use crate::app::state::AppState; // Ruta corregida a AppState
use crate::visual::{OptimizedRenderer, ShaderManager, render_frame};
use crate::config::AppConfig;
use crate::errors::{VisualizerError, VisualizerResult, init_error, config_error, window_error, sync_error}; // Importar tipos de error y macros
use crate::model::Model; // Usar el Model principal de model.rs
use crate::{log_system, log_visual, log_performance, log_osc}; // Importar macros de logging
use std::sync::Arc;
use tokio::sync::RwLock; // Mantener tokio para ShaderManager as√≠ncrono

// La definici√≥n de la estructura `Model` se ha eliminado de aqu√≠, ya que est√° definida en `crate::model`.

/// Inicializa la aplicaci√≥n con configuraci√≥n avanzada
pub async fn initialize_app(app: &App, config: AppConfig) -> anyhow::Result<Model> { // Hecho as√≠ncrono
    log_system!(Info, "üöÄ Inicializando aplicaci√≥n con configuraci√≥n avanzada...");
    
    // Configurar ventana usando par√°metros de configuraci√≥n
    log_system!(Info, "üñºÔ∏è Configurando ventana {}x{}", config.window.width, config.window.height); // Usar config.window
    let mut window_builder = app.new_window()
        .size(config.window.width, config.window.height)
        .title(&config.window.title)
        .view(render_frame)
        .key_pressed(handle_key_press);
    
    // Aplicar configuraci√≥n de pantalla completa si est√° habilitada
    if config.visual.fullscreen { // Usar config.visual
        log_system!(Info, "üñ•Ô∏è Configurando modo pantalla completa");
        window_builder = window_builder.fullscreen();
    }
    
    // Configurar vsync (Nannou no expone control directo, pero se mantiene el log)
    if !config.window.vsync { // Usar config.window
        log_system!(Info, "üîÑ VSync deshabilitado (configuraci√≥n)");
    }
    
    window_builder.build()
        .map_err(|e| window_error!(format!("Error creando ventana: {}", e)))?; // Usar macro window_error

    // Inicializar el Model principal de model.rs
    // El OscServer es ahora parte del Model, as√≠ que lo creamos primero.
    let osc_server = crate::osc_server::OscServer::new(config.osc.clone())
        .map_err(|e| init_error!("OSC Server", format!("Error inicializando servidor OSC: {}", e)))?;
    
    let mut model = Model::new_with_config(osc_server, config.clone()); // Pasar config al Model
    
    // Inicializar servidor MIDI dentro del Model
    model.init_midi();
    log_system!(Info, "‚è±Ô∏è Sincronizaci√≥n temporal configurada desde: {:.2}s", app.time);
    
    // Inicializar gestor de shaders con hot-reload si est√° habilitado
    if model.config.visual.shader_hot_reload { // Usar la config del modelo
        log_system!(Info, "üî• Configurando hot-reload de shaders...");
        
        // Llamar al m√©todo as√≠ncrono de inicializaci√≥n en el propio Model
        model.init_shader_manager().await
            .map_err(|e| init_error!("Shader Manager", format!("Error inicializando gestor de shaders: {}", e)))?;
        
        log_system!(Info, "‚úÖ Gestor de shaders inicializado y hot-reload activo.");
    } else {
        log_system!(Warning, "‚ö†Ô∏è Hot-reload de shaders deshabilitado por configuraci√≥n");
    }

    log_system!(Info, "‚úÖ Aplicaci√≥n inicializada correctamente con configuraci√≥n avanzada");
    log_system!(Info, "üìä Configuraci√≥n activa: max_notes={}, max_drones={}, max_cluster_particles={}", // Usar campos de configuraci√≥n relevantes
          config.performance.max_notes,
          config.performance.max_drones,
          config.performance.max_cluster_particles);
    
    Ok(model)
}

/// Actualiza el estado de la aplicaci√≥n
pub fn update_app(app: &App, model: &mut Model, update: Update) -> anyhow::Result<()> {
    // Actualizar tiempo y eventos usando los m√©todos del Model principal
    model.update_time(app.time); // Esto actualiza model.elapsed_time
    model.update_events(update.since_last.as_secs_f32()); // Esto actualiza notas/drones legacy y limpia
    model.update_visual_notes(update.since_last.as_secs_f32(), app.window_rect()); // Actualizar notas visuales profesionales

    // Log peri√≥dico del estado (cada 5 segundos)
    if (app.time as u64) % 5 == 0 && app.time.fract() < 0.01 {
        log_system!(Debug, "‚è±Ô∏è Estado: tiempo={:.2}s, eventos_activos_legacy={:?}", 
               app.time, model.get_active_events_count()); // Usar el m√©todo del modelo
    }
    
    Ok(())
}

/// Maneja las teclas presionadas
pub fn handle_key_press(app: &App, model: &mut Model, key: Key) {
    match key {
        Key::S => {
            log_system!(Info, "üì∏ Exportando visualizaci√≥n...");
            match export_visualization(app) {
                Ok(path) => {
                    log_system!(Info, "‚úÖ Visualizaci√≥n guardada como: {:?}", path);
                }
                Err(e) => {
                    log_system!(Error, "‚ùå Error exportando visualizaci√≥n: {}", e);
                }
            }
        },
        Key::D => {
            log_system!(Info, "üîç Alternando informaci√≥n de debug...");
            model.display_config.show_debug = !model.display_config.show_debug; // Actualizar directamente la config de display
            log_system!(Info, "üêõ Debug info: {}", if model.display_config.show_debug { "ON" } else { "OFF" });
        },
        Key::O => {
            log_system!(Info, "‚ö° Alternando optimizaci√≥n de batching...");
            model.config.performance.batching_enabled = !model.config.performance.batching_enabled; // Actualizar config directamente
            log_system!(Info, "üéØ Optimizaci√≥n: {}", if model.config.performance.batching_enabled { "ON" } else { "OFF" });
        },
        Key::P => {
            log_system!(Info, "üìä Estad√≠sticas de rendimiento:");
            // Obtener estad√≠sticas de los componentes del Modelo
            let osc_stats = model.osc_server.get_stats();
            log_performance!(Info, "üì° OSC: Total={}, Procesados={}, Errores={}, MPS={:.1}, Conectado={}",
                             osc_stats.total_received, osc_stats.total_processed,
                             osc_stats.total_errors, osc_stats.messages_per_second,
                             osc_stats.is_connected);
            log_performance!(Info, "üéµ Eventos Legacy: {} | Drones: {} | Notas Visuales: {}",
                             model.notes.len(), model.drone_events.len(), model.visual_notes.len());
        },
        Key::T => {
            log_system!(Info, "‚è±Ô∏è Alternando sincronizaci√≥n temporal...");
            // Esta funcionalidad necesita ser implementada en model.rs si a√∫n se desea.
            log_system!(Warning, "‚ö†Ô∏è Sincronizaci√≥n temporal no implementada en el modelo actual.");
        },
        Key::R => {
            log_system!(Info, "üîÑ Reiniciando tiempo y eventos...");
            model.elapsed_time = 0.0; // Resetear tiempo transcurrido
            model.osc_server.reset_stats(); // Resetear estad√≠sticas OSC
            model.clear_events(); // Limpiar todos los eventos (legacy y visuales)
            log_system!(Info, "‚úÖ Tiempo y eventos reiniciados.");
        },
        Key::C => {
            log_system!(Info, "üíæ Guardando configuraci√≥n actual...");
            let config_path = "config.toml"; // Usar el config.toml est√°ndar
            match model.config.save_to_file(config_path) {
                Ok(_) => {
                    log_system!(Info, "‚úÖ Configuraci√≥n guardada en: {}", config_path);
                }
                Err(e) => {
                    log_system!(Error, "‚ùå Error guardando configuraci√≥n: {}", e);
                }
            }
        },
        Key::H => {
            log_system!(Info, "üî• Recompilando shaders...");
            let shader_manager_arc = Arc::clone(&model.shader_manager);
            // Usar std::thread::spawn y block_on para llamadas as√≠ncronas en un contexto s√≠ncrono
            std::thread::spawn(move || {
                let rt = tokio::runtime::Runtime::new().unwrap();
                rt.block_on(async {
                    if let Some(manager) = shader_manager_arc.read().await.as_ref() {
                        match manager.force_recompile_all().await {
                            Ok(_) => {
                                log_system!(Info, "‚úÖ Shaders recompilados exitosamente");
                            }
                            Err(e) => {
                                log_system!(Error, "‚ùå Error recompilando shaders: {}", e);
                            }
                        }
                    } else {
                        log_system!(Warning, "‚ö†Ô∏è Gestor de shaders no est√° disponible");
                    }
                });
            });
        },
        Key::L => {
            log_system!(Info, "üìã Listando shaders disponibles...");
            let shader_manager_arc = Arc::clone(&model.shader_manager);
            std::thread::spawn(move || {
                let rt = tokio::runtime::Runtime::new().unwrap();
                rt.block_on(async {
                    if let Some(manager) = shader_manager_arc.read().await.as_ref() {
                        let shaders = manager.list_shaders().await;
                        let (total, success, errors) = manager.get_compilation_stats().await;
                        
                        log_system!(Info, "üìä Estad√≠sticas de shaders: {} total, {} exitosos, {} con errores", total, success, errors);
                        for shader in shaders {
                            let status = match shader.compile_status {
                                crate::visual::CompileStatus::Success => "‚úÖ",
                                crate::visual::CompileStatus::Error(_) => "‚ùå",
                                crate::visual::CompileStatus::Pending => "‚è≥",
                            };
                            log_system!(Info, "   {} {} ({})", status, shader.name, shader.shader_type.to_string());
                        }
                    } else {
                        log_system!(Warning, "‚ö†Ô∏è Gestor de shaders no est√° disponible");
                    }
                });
            });
        },
        _ => {}
    }
}

/// Exporta la visualizaci√≥n actual
fn export_visualization(app: &App) -> VisualizerResult<std::path::PathBuf> {
    log_system!(Debug, "üîß Preparando exportaci√≥n de visualizaci√≥n");
    
    let window = app.main_window();
    let path = app.assets_path()
        .unwrap_or_else(|_| std::env::current_dir().unwrap())
        .join(format!("visualizer_export_{}.png", app.time as u32));
    
    log_system!(Debug, "üíæ Capturando frame en: {:?}", path);
    window.capture_frame(&path);
    
    Ok(path)
}
